<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Track Ride - Drift</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" href="/favicon.png">
    
    <!-- Google Maps API (loaded asynchronously for better performance) -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key=AIzaSyD94ZFCQvkJjyqjIGFmZ7ASpZX9vRvwbjk&libraries=geometry,places&loading=async&callback=onMapsApiLoaded"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore-compat.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            height: 100vh;
        }

        /* Header */
        .header {
            background: #ffffff;
            padding: 16px 20px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            position: relative;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-text {
            font-size: 24px;
            font-weight: 700;
            color: #2563eb;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #10b981;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: white;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Main Content */
        .container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 70px);
        }

        /* Map Container */
        #map {
            flex: 1;
            width: 100%;
            position: relative;
        }

        /* Info Panel */
        .info-panel {
            background: white;
            padding: 20px;
            box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
            max-height: 40vh;
            overflow-y: auto;
        }

        .info-panel-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .driver-info {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .driver-avatar {
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
            font-weight: 700;
        }

        .driver-details {
            flex: 1;
        }

        .driver-name {
            font-size: 18px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 4px;
        }

        .vehicle-info {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #6b7280;
            font-size: 14px;
        }

        .vehicle-icon {
            width: 20px;
            height: 20px;
        }

        /* Trip Details */
        .trip-details {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-bottom: 16px;
        }

        .detail-card {
            padding: 12px;
            background: #f9fafb;
            border-radius: 8px;
        }

        .detail-label {
            font-size: 12px;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .detail-value {
            font-size: 16px;
            font-weight: 600;
            color: #111827;
        }

        /* Destination Info */
        .destination-info {
            display: flex;
            align-items: start;
            gap: 12px;
            padding: 16px;
            background: #eff6ff;
            border-radius: 12px;
            border-left: 4px solid #2563eb;
        }

        .destination-icon {
            width: 24px;
            height: 24px;
            color: #2563eb;
            margin-top: 2px;
        }

        .destination-text {
            flex: 1;
        }

        .destination-label {
            font-size: 12px;
            color: #1e40af;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .destination-address {
            font-size: 14px;
            color: #1e3a8a;
            line-height: 1.4;
        }

        /* Loading State */
        .loading-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid #e5e7eb;
            border-top-color: #2563eb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            font-size: 16px;
            color: #6b7280;
        }

        /* Error State */
        .error-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            text-align: center;
        }

        .error-icon {
            width: 80px;
            height: 80px;
            background: #fef2f2;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 20px;
        }

        .error-title {
            font-size: 24px;
            font-weight: 600;
            color: #111827;
            margin-bottom: 8px;
        }

        .error-message {
            font-size: 16px;
            color: #6b7280;
            max-width: 400px;
        }

        /* Completed State */
        .completed-banner {
            background: #10b981;
            color: white;
            padding: 12px 20px;
            text-align: center;
            font-weight: 600;
            display: none;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .info-panel {
                max-height: 50vh;
            }

            .trip-details {
                grid-template-columns: 1fr;
            }

            .driver-info {
                flex-direction: column;
                text-align: center;
            }
        }

        /* Hide elements initially */
        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <!-- Loading State -->
    <div id="loading" class="loading-container">
        <div class="spinner"></div>
        <div class="loading-text">Loading trip details...</div>
    </div>

    <!-- Error State -->
    <div id="error" class="error-container hidden">
        <div class="error-icon">
            <svg width="40" height="40" fill="none" stroke="#ef4444" stroke-width="2" viewBox="0 0 24 24">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
            </svg>
        </div>
        <div class="error-title">Trip Not Found</div>
        <div class="error-message">This tracking link is invalid or has expired. Please ask the rider to share a new link.</div>
    </div>

    <!-- Completed Banner -->
    <div id="completedBanner" class="completed-banner">
        ‚úì Trip completed successfully
    </div>

    <!-- Main Content -->
    <div id="mainContent" class="hidden">
        <!-- Header -->
        <header class="header">
            <div class="header-content">
                <div class="logo">
                    <svg width="32" height="32" viewBox="0 0 32 32" fill="none">
                        <circle cx="16" cy="16" r="14" fill="#2563eb" opacity="0.1"/>
                        <path d="M16 8L20 12H12L16 8Z" fill="#2563eb"/>
                        <rect x="14" y="12" width="4" height="8" rx="1" fill="#2563eb"/>
                        <circle cx="16" cy="22" r="2" fill="#2563eb"/>
                    </svg>
                    <span class="logo-text">Drift</span>
                </div>
                <div id="statusBadge" class="status-badge">
                    <div class="status-dot"></div>
                    <span>Live Tracking</span>
                </div>
            </div>
        </header>

        <!-- Container -->
        <div class="container">
            <!-- Map -->
            <div id="map"></div>

            <!-- Info Panel -->
            <div class="info-panel">
                <div class="info-panel-content">
                    <!-- Driver Info -->
                    <div class="driver-info">
                        <div class="driver-avatar" id="driverAvatar">D</div>
                        <div class="driver-details">
                            <div class="driver-name" id="driverName">Loading...</div>
                            <div class="vehicle-info">
                                <svg class="vehicle-icon" fill="currentColor" viewBox="0 0 20 20">
                                    <path d="M8 16.5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0zM15 16.5a1.5 1.5 0 11-3 0 1.5 1.5 0 013 0z"/>
                                    <path d="M3 4a1 1 0 00-1 1v10a1 1 0 001 1h1.05a2.5 2.5 0 014.9 0h2.1a2.5 2.5 0 014.9 0H17a1 1 0 001-1V5a1 1 0 00-1-1H3zM14 7a1 1 0 00-1 1v3a1 1 0 001 1h2V7h-2z"/>
                                </svg>
                                <span id="vehicleInfo">Loading...</span>
                            </div>
                        </div>
                    </div>

                    <!-- Trip Details -->
                    <div class="trip-details">
                        <div class="detail-card">
                            <div class="detail-label">Distance</div>
                            <div class="detail-value" id="distance">Calculating...</div>
                        </div>
                        <div class="detail-card">
                            <div class="detail-label">ETA</div>
                            <div class="detail-value" id="eta">Calculating...</div>
                        </div>
                        <div class="detail-card">
                            <div class="detail-label">Last Updated</div>
                            <div class="detail-value" id="lastUpdated">Just now</div>
                        </div>
                    </div>

                    <!-- Destination -->
                    <div class="destination-info">
                        <svg class="destination-icon" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd"/>
                        </svg>
                        <div class="destination-text">
                            <div class="destination-label">Destination</div>
                            <div class="destination-address" id="destination">Loading...</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase Configuration
        // NOTE: This API key is a client-side Firebase Web API key, not a secret.
        // Firebase security is enforced via Firestore Security Rules, not API key restrictions.
        // See: https://firebase.google.com/docs/projects/api-keys
        const firebaseConfig = {
            apiKey: "AIzaSyBZ_o4ZcHPvuNnTsqSaJ1CYl2l2PkJoOno",
            authDomain: "drift-global.firebaseapp.com",
            projectId: "drift-global",
            storageBucket: "drift-global.firebasestorage.app",
            messagingSenderId: "693488691443",
            appId: "1:693488691443:android:04e0f57cbb1ba61ea96b47"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        // Use 'main' database (restored from backup) - UPGRADED TO v23.5.0
        const db = firebase.app().firestore('main');

        // Global variables
        let map;
        let driverMarker;
        let destinationMarker;
        let pickupMarker;
        let routeLine;
        let sessionId;
        let unsubscribe;
        let mapsApiLoaded = false;
        let pendingMapInit = null;
        let directionsService;
        let directionsRenderer;
        let currentRoute = null;
        let lastRouteRequest = null;
        let tripData = null; // Store trip data globally for route updates

        // Callback when Google Maps API is loaded
        function onMapsApiLoaded() {
            mapsApiLoaded = true;
            console.log('Google Maps API loaded');
            // If we have pending data to display, initialize the map now
            if (pendingMapInit) {
                initMap(pendingMapInit.lat, pendingMapInit.lng);
                if (pendingMapInit.callback) {
                    pendingMapInit.callback();
                }
                pendingMapInit = null;
            }
        }

        // Get session/trip ID from URL
        // Supports multiple formats:
        // - /track?tripId=ABC123 (preferred - new format)
        // - /track?session=ABC123 (legacy)
        // - /track?id=ABC123 (legacy)
        // - /track/ABC123 (path-based legacy)
        function getSessionId() {
            const urlParams = new URLSearchParams(window.location.search);

            // First check for 'tripId' query param (new preferred format)
            const tripIdParam = urlParams.get('tripId');
            if (tripIdParam) return tripIdParam;

            // Then check for 'session' query param (legacy format)
            const sessionParam = urlParams.get('session');
            if (sessionParam) return sessionParam;

            // Then check for 'id' query param (legacy format)
            const idParam = urlParams.get('id');
            if (idParam) return idParam;

            // Finally check URL path (legacy format)
            const pathParts = window.location.pathname.split('/');
            const lastPart = pathParts[pathParts.length - 1];
            if (lastPart && lastPart !== 'track' && lastPart !== 'track.html') {
                return lastPart;
            }

            return null;
        }

        // Initialize map
        function initMap(lat = 19.2866, lng = -81.3744) {
            map = new google.maps.Map(document.getElementById('map'), {
                center: { lat, lng },
                zoom: 13,
                disableDefaultUI: false,
                zoomControl: true,
                mapTypeControl: false,
                streetViewControl: false,
                fullscreenControl: true,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });

            // Initialize Directions Service and Renderer
            directionsService = new google.maps.DirectionsService();
            directionsRenderer = new google.maps.DirectionsRenderer({
                map: map,
                suppressMarkers: true, // We'll use custom markers
                polylineOptions: {
                    strokeColor: '#5d1289',
                    strokeOpacity: 0.8,
                    strokeWeight: 5,
                }
            });

            // Create driver marker (car icon) - custom SVG car
            const carIconSvg = `
                <svg width="40" height="40" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <circle cx="20" cy="20" r="18" fill="#5d1289" stroke="white" stroke-width="3"/>
                    <path d="M12 22V26C12 26.5523 12.4477 27 13 27H15C15.5523 27 16 26.5523 16 26V25H24V26C24 26.5523 24.4477 27 25 27H27C27.5523 27 28 26.5523 28 26V22M12 22L14 15C14.1667 14.3333 14.8 13 16 13H24C25.2 13 25.8333 14.3333 26 15L28 22M12 22H28M15 23.5C15 24.3284 14.3284 25 13.5 25C12.6716 25 12 24.3284 12 23.5C12 22.6716 12.6716 22 13.5 22C14.3284 22 15 22.6716 15 23.5ZM28 23.5C28 24.3284 27.3284 25 26.5 25C25.6716 25 25 24.3284 25 23.5C25 22.6716 25.6716 22 26.5 22C27.3284 22 28 22.6716 28 23.5Z" stroke="white" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            `;

            driverMarker = new google.maps.Marker({
                map: map,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(carIconSvg),
                    scaledSize: new google.maps.Size(40, 40),
                    anchor: new google.maps.Point(20, 20),
                },
                title: 'Driver Location',
                zIndex: 1000 // Keep car on top
            });

            // Create pickup marker (green)
            const pickupIconSvg = `
                <svg width="32" height="40" viewBox="0 0 32 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16 0C7.16344 0 0 7.16344 0 16C0 24.8366 16 40 16 40C16 40 32 24.8366 32 16C32 7.16344 24.8366 0 16 0Z" fill="#10b981"/>
                    <circle cx="16" cy="16" r="6" fill="white"/>
                </svg>
            `;

            pickupMarker = new google.maps.Marker({
                map: map,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(pickupIconSvg),
                    scaledSize: new google.maps.Size(32, 40),
                    anchor: new google.maps.Point(16, 40),
                },
                title: 'Pickup Location',
                visible: false
            });

            // Create destination marker (red)
            const destIconSvg = `
                <svg width="32" height="40" viewBox="0 0 32 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M16 0C7.16344 0 0 7.16344 0 16C0 24.8366 16 40 16 40C16 40 32 24.8366 32 16C32 7.16344 24.8366 0 16 0Z" fill="#ef4444"/>
                    <circle cx="16" cy="16" r="6" fill="white"/>
                </svg>
            `;

            destinationMarker = new google.maps.Marker({
                map: map,
                icon: {
                    url: 'data:image/svg+xml;charset=UTF-8,' + encodeURIComponent(destIconSvg),
                    scaledSize: new google.maps.Size(32, 40),
                    anchor: new google.maps.Point(16, 40),
                },
                title: 'Destination'
            });

            // Create fallback route line (used only if Directions API fails)
            routeLine = new google.maps.Polyline({
                map: map,
                strokeColor: '#5d1289',
                strokeOpacity: 0.7,
                strokeWeight: 4,
                visible: false
            });
        }

        // Fetch and display route using Directions API
        function fetchRoute(origin, destination, waypoints = []) {
            if (!directionsService || !directionsRenderer) {
                console.log('‚ö†Ô∏è Directions service not ready');
                return;
            }

            // Create request key to avoid duplicate requests
            const requestKey = `${origin.lat.toFixed(4)},${origin.lng.toFixed(4)}-${destination.lat.toFixed(4)},${destination.lng.toFixed(4)}`;
            if (lastRouteRequest === requestKey && currentRoute) {
                console.log('üìç Using cached route');
                return;
            }

            console.log('üìç Fetching route from Directions API...');

            const request = {
                origin: origin,
                destination: destination,
                waypoints: waypoints.map(wp => ({
                    location: new google.maps.LatLng(wp.lat, wp.lng),
                    stopover: true
                })),
                travelMode: google.maps.TravelMode.DRIVING,
                optimizeWaypoints: false
            };

            directionsService.route(request, (result, status) => {
                if (status === 'OK') {
                    console.log('‚úÖ Route fetched successfully');
                    directionsRenderer.setDirections(result);
                    currentRoute = result;
                    lastRouteRequest = requestKey;
                    routeLine.setVisible(false); // Hide fallback line

                    // Update ETA from Directions API
                    if (result.routes[0] && result.routes[0].legs[0]) {
                        const leg = result.routes[0].legs[0];
                        document.getElementById('distance').textContent = leg.distance.text;
                        document.getElementById('eta').textContent = leg.duration.text;
                    }
                } else {
                    console.log('‚ö†Ô∏è Directions API failed:', status);
                    // Fall back to straight line
                    routeLine.setPath([origin, destination]);
                    routeLine.setVisible(true);
                }
            });
        }

        // Smoothly animate marker to new position
        function animateMarker(marker, newPosition, duration = 1000) {
            const startPosition = marker.getPosition();
            if (!startPosition) {
                marker.setPosition(newPosition);
                return;
            }

            const startLat = startPosition.lat();
            const startLng = startPosition.lng();
            const endLat = newPosition.lat;
            const endLng = newPosition.lng;

            const startTime = Date.now();

            function animate() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Ease out cubic for smooth deceleration
                const easeProgress = 1 - Math.pow(1 - progress, 3);

                const currentLat = startLat + (endLat - startLat) * easeProgress;
                const currentLng = startLng + (endLng - startLng) * easeProgress;

                marker.setPosition({ lat: currentLat, lng: currentLng });

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate();
        }

        // Update map with new data
        let initialBoundsFit = false;
        let lastDriverPos = null;

        function updateMap(data) {
            if (!data.destination || !data.destination.latitude) {
                console.log('‚ö†Ô∏è No destination data available');
                return;
            }

            // Store trip data for later use
            tripData = data;

            const destPos = {
                lat: data.destination.latitude,
                lng: data.destination.longitude
            };

            // Update destination marker
            destinationMarker.setPosition(destPos);
            destinationMarker.setVisible(true);

            // Show pickup marker if trip hasn't started yet
            if (data.pickup && data.pickup.latitude) {
                const pickupPos = {
                    lat: data.pickup.latitude,
                    lng: data.pickup.longitude
                };
                pickupMarker.setPosition(pickupPos);

                // Show pickup marker only if driver is going to pickup (not yet at destination)
                const isGoingToPickup = data.tripStatus === 'ACCEPTED' || data.tripStatus === 'DRIVER_ARRIVING';
                pickupMarker.setVisible(isGoingToPickup);
            }

            const bounds = new google.maps.LatLngBounds();
            bounds.extend(destPos);

            // Update driver marker if we have location
            if (data.currentLocation && data.currentLocation.latitude) {
                const driverPos = {
                    lat: data.currentLocation.latitude,
                    lng: data.currentLocation.longitude
                };

                // Smoothly animate to new position (if not first position)
                if (lastDriverPos) {
                    animateMarker(driverMarker, driverPos, 2000);
                } else {
                    driverMarker.setPosition(driverPos);
                }
                lastDriverPos = driverPos;

                driverMarker.setVisible(true);

                bounds.extend(driverPos);

                // Fetch route if we don't have one yet
                if (!currentRoute) {
                    // Determine origin and destination based on trip status
                    if (data.tripStatus === 'IN_PROGRESS') {
                        // Trip in progress: route from driver to destination
                        fetchRoute(driverPos, destPos);
                    } else if (data.pickup && data.pickup.latitude) {
                        // Driver going to pickup: route from driver to pickup
                        const pickupPos = { lat: data.pickup.latitude, lng: data.pickup.longitude };
                        fetchRoute(driverPos, pickupPos);
                        bounds.extend(pickupPos);
                    }
                }

                // Fallback metrics if Directions API hasn't responded
                if (!currentRoute) {
                    updateTripMetrics(driverPos, destPos);
                }
            } else {
                // Hide driver marker if no location
                driverMarker.setVisible(false);

                // Show "Waiting for driver location" in metrics
                document.getElementById('distance').textContent = 'Waiting...';
                document.getElementById('eta').textContent = 'Waiting for driver';
            }

            // Fit bounds only once initially
            if (!initialBoundsFit) {
                map.fitBounds(bounds);
                initialBoundsFit = true;

                // Don't zoom in too much
                const listener = google.maps.event.addListener(map, 'idle', function() {
                    if (map.getZoom() > 16) map.setZoom(16);
                    google.maps.event.removeListener(listener);
                });
            }
        }

        // Update trip metrics
        function updateTripMetrics(driverPos, destPos) {
            // Calculate distance
            const distance = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(driverPos.lat, driverPos.lng),
                new google.maps.LatLng(destPos.lat, destPos.lng)
            );

            const distanceKm = (distance / 1000).toFixed(1);
            const distanceMiles = (distance / 1609.34).toFixed(1);
            document.getElementById('distance').textContent = `${distanceKm} km (${distanceMiles} mi)`;

            // Estimate ETA (assuming average speed of 40 km/h in Cayman traffic)
            const averageSpeedKmh = 40;
            const etaMinutes = Math.round((distance / 1000) / averageSpeedKmh * 60);
            
            if (etaMinutes < 1) {
                document.getElementById('eta').textContent = 'Arriving now';
            } else if (etaMinutes < 60) {
                document.getElementById('eta').textContent = `${etaMinutes} min`;
            } else {
                const hours = Math.floor(etaMinutes / 60);
                const mins = etaMinutes % 60;
                document.getElementById('eta').textContent = `${hours}h ${mins}m`;
            }
        }

        // Update UI with session data
        function updateUI(data) {
            // Driver name
            const firstName = data.driverName || 'Driver';
            document.getElementById('driverName').textContent = firstName;
            document.getElementById('driverAvatar').textContent = firstName.charAt(0).toUpperCase();

            // Vehicle info
            const vehicle = data.vehicleInfo;
            if (vehicle && (vehicle.make || vehicle.model)) {
                const plateDisplay = vehicle.licensePlate ? ` ‚Ä¢ ${vehicle.licensePlate.slice(-4)}` : '';
                document.getElementById('vehicleInfo').textContent =
                    `${vehicle.color} ${vehicle.make} ${vehicle.model}${plateDisplay}`.trim();
            } else {
                document.getElementById('vehicleInfo').textContent = 'Vehicle info loading...';
            }

            // Destination
            document.getElementById('destination').textContent = data.destination?.address || 'Loading...';

            // Last updated
            if (data.currentLocation?.timestamp) {
                updateLastUpdated(data.currentLocation.timestamp);
            } else {
                document.getElementById('lastUpdated').textContent = 'Waiting for updates';
            }

            // Update status badge based on trip status
            if (data.tripStatus) {
                const statusBadge = document.getElementById('statusBadge');
                const statusText = getTripStatusText(data.tripStatus);
                const statusColor = getTripStatusColor(data.tripStatus);

                statusBadge.innerHTML = `<div class="status-dot"></div><span>${statusText}</span>`;
                statusBadge.style.background = statusColor;
            }
        }

        // Get human-readable trip status
        function getTripStatusText(status) {
            switch (status) {
                case 'REQUESTED': return 'Finding driver';
                case 'ACCEPTED': return 'Driver assigned';
                case 'DRIVER_ARRIVING': return 'Driver en route';
                case 'DRIVER_ARRIVED': return 'Driver arrived';
                case 'IN_PROGRESS': return 'Trip in progress';
                case 'AWAITING_TIP': return 'Trip completed';
                case 'COMPLETED': return 'Trip completed';
                case 'CANCELLED': return 'Cancelled';
                default: return 'Live Tracking';
            }
        }

        // Get status badge color
        function getTripStatusColor(status) {
            switch (status) {
                case 'REQUESTED': return '#f59e0b'; // amber
                case 'ACCEPTED': return '#3b82f6'; // blue
                case 'DRIVER_ARRIVING': return '#8b5cf6'; // purple
                case 'DRIVER_ARRIVED': return '#10b981'; // green
                case 'IN_PROGRESS': return '#10b981'; // green
                case 'AWAITING_TIP':
                case 'COMPLETED': return '#6b7280'; // gray
                case 'CANCELLED': return '#ef4444'; // red
                default: return '#10b981';
            }
        }

        // Update last updated timestamp
        function updateLastUpdated(timestamp) {
            if (!timestamp) return;

            const now = Date.now();
            const then = timestamp.toMillis ? timestamp.toMillis() : timestamp;
            const diff = Math.floor((now - then) / 1000);

            let text;
            if (diff < 10) {
                text = 'Just now';
            } else if (diff < 60) {
                text = `${diff}s ago`;
            } else if (diff < 3600) {
                text = `${Math.floor(diff / 60)}m ago`;
            } else {
                text = `${Math.floor(diff / 3600)}h ago`;
            }

            document.getElementById('lastUpdated').textContent = text;
        }

        // Show error
        function showError() {
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('error').classList.remove('hidden');
            document.getElementById('mainContent').classList.add('hidden');
        }

        // Show completed state
        function showCompleted() {
            document.getElementById('completedBanner').style.display = 'block';
            document.getElementById('statusBadge').innerHTML = '<span>‚úì Completed</span>';
            document.getElementById('statusBadge').style.background = '#6b7280';
        }

        // Handle tracking session data (from trackingSessions collection)
        function handleTrackingSessionData(data) {
            // Check if expired or not active
            if (data.status === 'expired' ||
                (data.expiresAt && data.expiresAt.toMillis() < Date.now())) {
                showError();
                return;
            }

            // Check if completed
            if (data.status === 'completed') {
                showCompleted();
            }

            // Hide loading, show main content
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('mainContent').classList.remove('hidden');

            // Initialize map if needed
            if (!map && data.currentLocation) {
                if (mapsApiLoaded) {
                    initMap(
                        data.currentLocation.latitude,
                        data.currentLocation.longitude
                    );
                    updateUI(data);
                    updateMap(data);
                } else {
                    // Maps API not loaded yet, queue the initialization
                    pendingMapInit = {
                        lat: data.currentLocation.latitude,
                        lng: data.currentLocation.longitude,
                        callback: () => {
                            updateUI(data);
                            updateMap(data);
                        }
                    };
                    updateUI(data);
                }
                return;
            }

            // Update UI and map
            updateUI(data);
            if (mapsApiLoaded && map) {
                updateMap(data);
            }
        }

        // Handle trip data (from trips collection) - convert to tracking format
        function handleTripData(data, tripId) {
            console.log('üìç Processing trip data:', {
                status: data.status,
                hasDriverInfo: !!data.driverInfo,
                hasDriverLocation: !!data.driverLocation,
                hasDestination: !!data.destination
            });

            // Check if trip is cancelled
            if (data.status === 'CANCELLED') {
                showError();
                return;
            }

            // Check if completed
            if (data.status === 'COMPLETED' || data.status === 'AWAITING_TIP') {
                showCompleted();
            }

            // Hide loading, show main content
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('mainContent').classList.remove('hidden');

            // Get driver location (prefer driverLocation, fall back to driverFinalLocation)
            const driverLoc = data.driverLocation || data.driverFinalLocation;

            // Get destination coordinates - handle nested structure
            const destCoords = data.destination?.coordinates;
            const pickupCoords = data.pickup?.coordinates;

            // Convert trip data to tracking format for UI
            const trackingData = {
                driverName: data.driverInfo?.name?.split(' ')[0] || 'Driver', // First name only
                vehicleInfo: data.driverInfo?.vehicle ? {
                    color: data.driverInfo.vehicle.color || '',
                    make: data.driverInfo.vehicle.make || '',
                    model: data.driverInfo.vehicle.model || '',
                    licensePlate: data.driverInfo.vehicle.plate || '' // Note: field is 'plate' not 'licensePlate'
                } : { color: '', make: '', model: '', licensePlate: '' },
                destination: {
                    address: data.destination?.address || data.destination?.placeName || 'Destination',
                    latitude: destCoords?.latitude,
                    longitude: destCoords?.longitude
                },
                pickup: {
                    address: data.pickup?.address || data.pickup?.placeName || 'Pickup',
                    latitude: pickupCoords?.latitude,
                    longitude: pickupCoords?.longitude
                },
                currentLocation: driverLoc ? {
                    latitude: driverLoc.latitude,
                    longitude: driverLoc.longitude,
                    heading: driverLoc.heading,
                    timestamp: driverLoc.timestamp
                } : null,
                tripStatus: data.status
            };

            console.log('üìç Converted tracking data:', trackingData);

            // Initialize map if we have location data
            if (!map) {
                // Priority: driver location > pickup > destination > default (Cayman)
                const initLat = driverLoc?.latitude || pickupCoords?.latitude || destCoords?.latitude || 19.2866;
                const initLng = driverLoc?.longitude || pickupCoords?.longitude || destCoords?.longitude || -81.3744;

                if (mapsApiLoaded) {
                    initMap(initLat, initLng);
                    updateUI(trackingData);
                    if (trackingData.destination.latitude) {
                        updateMap(trackingData);
                    }
                } else {
                    // Maps API not loaded yet, queue the initialization
                    pendingMapInit = {
                        lat: initLat,
                        lng: initLng,
                        callback: () => {
                            updateUI(trackingData);
                            if (trackingData.destination.latitude) {
                                updateMap(trackingData);
                            }
                        }
                    };
                    updateUI(trackingData);
                }
                return;
            }

            updateUI(trackingData);
            if (mapsApiLoaded && map && trackingData.destination.latitude) {
                updateMap(trackingData);
            }
        }

        // Initialize tracking
        async function initTracking() {
            sessionId = getSessionId();

            if (!sessionId) {
                showError();
                return;
            }

            try {
                // First, try the trackingSessions collection
                const trackingDoc = await db.collection('trackingSessions').doc(sessionId).get();

                if (trackingDoc.exists) {
                    console.log('Found tracking session');
                    // Subscribe to real-time updates from trackingSessions
                    unsubscribe = db.collection('trackingSessions')
                        .doc(sessionId)
                        .onSnapshot((doc) => {
                            if (!doc.exists) {
                                showError();
                                return;
                            }
                            handleTrackingSessionData(doc.data());
                        }, (error) => {
                            console.error('Error fetching tracking session:', error);
                            showError();
                        });
                } else {
                    // Fall back to trips collection (direct trip sharing)
                    console.log('Tracking session not found, checking trips collection');
                    const tripDoc = await db.collection('trips').doc(sessionId).get();

                    if (tripDoc.exists) {
                        console.log('Found trip');
                        // Subscribe to real-time updates from trips
                        unsubscribe = db.collection('trips')
                            .doc(sessionId)
                            .onSnapshot((doc) => {
                                if (!doc.exists) {
                                    showError();
                                    return;
                                }
                                handleTripData(doc.data(), sessionId);
                            }, (error) => {
                                console.error('Error fetching trip:', error);
                                showError();
                            });
                    } else {
                        console.log('Neither tracking session nor trip found');
                        showError();
                    }
                }

                // Update "last updated" every 10 seconds
                setInterval(() => {
                    const lastUpdatedEl = document.getElementById('lastUpdated');
                    if (lastUpdatedEl && !lastUpdatedEl.textContent.includes('Just now')) {
                        // Trigger re-render (will be updated on next snapshot)
                    }
                }, 10000);

            } catch (error) {
                console.error('Error initializing tracking:', error);
                showError();
            }
        }

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (unsubscribe) {
                unsubscribe();
            }
        });

        // Start tracking when page loads
        window.addEventListener('load', initTracking);
    </script>
</body>
</html>